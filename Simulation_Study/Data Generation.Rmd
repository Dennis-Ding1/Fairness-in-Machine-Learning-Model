---
title: "Data Generation"
---

```{r}
generate_data <- function(
  n = 2000,
  pA = 0.5,
  mu_X = c(60, 120),          # mean for each covariate
  sd_X = c(10, 15),           # sd for each covariate
  beta_X = c(0.03, 0.014),    # coefficients for covariates
  beta_A = 0,                 # group effect
  lambda = 0.004,             # baseline rate for Weibull
  k = 1.5,                    # shape parameter
  mu = 0.1,                   # baseline censoring rate
  alpha = 0,                  # censoring dependence
  Cmax_A0 = 10,               # max follow-up (group 0)
  Cmax_A1 = 10,               # max follow-up (group 1)
  seed = 123
) {
  set.seed(seed)
  
  pX <- length(mu_X)
  if (length(sd_X) != pX | length(beta_X) != pX)
    stop("Lengths of mu_X, sd_X, and beta_X doesn't match.")
  
  # Sensitive attribute
  A <- rbinom(n, 1, pA)
  
  # Covariates
  X <- matrix(NA, nrow = n, ncol = pX)
  for (j in 1:pX) {
    X[, j] <- rnorm(n, mean = mu_X[j], sd = sd_X[j])
  }
  colnames(X) <- c("age", "LOS", "eGFR", "Hemoglobin", "CCI")
  
  # True event time 
  Z <- scale(X, center = mu_X, scale = sd_X)
  eta <- as.vector(Z %*% beta_X) + beta_A * A
  
  # eta <- beta_A * A + X %*% beta_X
  U <- runif(n)
  T_true <- ((-log(U)) / (lambda * exp(eta)))^(1 / k)
  
  #  Censoring time
  C <- rexp(n, rate = mu * exp(alpha * eta))
  
  # Max follow-up
  Cmax <- ifelse(A == 0, Cmax_A0, Cmax_A1)
  
  # Observed data
  Y <- pmin(T_true, C, Cmax)
  Delta <- as.numeric(T_true <= pmin(C, Cmax))
  
  data <- data.frame(
    id = 1:n,
    A = A,
    X,
    T_true = T_true,
    C = C,
    Cmax = Cmax,
    Y = Y,
    Delta = Delta
  )
  
  return(data)
}



```

```{r}
# Example

# X choice:
mu_X = c(50,    # age
         3,   # LOS (Length of Stay)
         70,    # eGFR
         13.2,  # Hemoglobin
         2)     # CCI (Charlson Comorbidity Index)
         

sd_X = c(15,    # age
         2.5,   # LOS (Length of Stay)
         20,    # eGFR
         1.6,  # Hemoglobin
         1.5)     # CCI (Charlson Comorbidity Index)

beta_X = c(0.3,  # age
         0.4,   # LOS (Length of Stay)
         -0.22,    # eGFR
         -0.3,  # Hemoglobin
         0.35)     # CCI (Charlson Comorbidity Index)

k <- 1.2
lambda <- 0.03
mu <- 0.03

# Scenario I: all assumptions hold
data_I <- generate_data(
  n = 5000,
  mu_X = mu_X,
  sd_X = sd_X,
  beta_X = beta_X,
  lambda = lambda,
  k = k,
  mu = mu,
  beta_A = 0,
  alpha = 0,
  Cmax_A0 = 50,
  Cmax_A1 = 50
)

# Scenario II: violation of assumptions
data_II <- generate_data(
  n = 5000,
  mu_X = mu_X,
  sd_X = sd_X,
  beta_X = beta_X,
  lambda = 0.004,
  k = 1.5,
  mu = mu, 
  beta_A = 0.5,
  alpha = 0.5,
  Cmax_A0 = 15,
  Cmax_A1 = 10
)


head(data_I)
head(data_II)


```

```{r}
# Quick EDA
library(ggplot2)

dat <- data_I

cat("Dataset size:", nrow(dat), "\n")
cat("Columns:", names(dat), "\n")

summary(dat)

cat("\nOverall censoring rate:\n")
mean(dat$Delta == 0)

cat("\nCensoring rate by group (A=0, A=1):\n")
tapply(dat$Delta == 0, dat$A, mean)


ggplot(dat, aes(x = Y, fill = factor(A))) +
  geom_histogram(alpha = 0.5, bins = 40, position = "identity") +
  labs(title = "Observed Time Distribution by Group",
       x = "Observed Time (Y)",
       fill = "Group A") +
  theme_minimal()

ggplot(dat, aes(x = Y, fill = factor(Delta))) +
  geom_histogram(alpha = 0.5, bins = 40, position = "identity") +
  labs(title = "Events (Δ=1) vs Censored (Δ=0)",
       x = "Observed Time",
       fill = "Event Indicator") +
  theme_minimal()

ggplot(dat, aes(x = age, fill = factor(A))) +
  geom_histogram(alpha = 0.5, bins = 40, position = "identity") +
  labs(title = "Age Distribution by Group", fill = "Group A") +
  theme_minimal()

ggplot(dat, aes(x = LOS, fill = factor(A))) +
  geom_histogram(alpha = 0.5, bins = 40, position = "identity") +
  labs(title = "LOS Distribution by Group", fill = "Group A") +
  theme_minimal()


```

```{r}
write.csv(data_I, "data/data_I.csv", row.names = FALSE)
write.csv(data_II, "data/data_II.csv", row.names = FALSE)
```


```{r}
library(survival)
fit <- coxph(Surv(Y, Delta) ~ age + LOS + eGFR + Hemoglobin + CCI, data = data_I, x = TRUE)
summary(fit)$concordance 
```

```{r}
library(pec)

# ==========================================
# Function: evaluate_IBS
# ==========================================
# 输入：
#   fit       - 已拟合好的 coxph 模型对象
#   data      - 用于评估的 data.frame
#   time_col  - 存储生存时间的列名（字符串）
#   status_col - 存储删失指标的列名（字符串）
# 输出：
#   返回 IBS 值，并绘制 Brier Score 曲线
# ==========================================

evaluate_IBS <- function(fit, data, time_col = "Y", status_col = "Delta") {
  # Step 1. 计算时间点
  time_vec  <- data[[time_col]]
  eval_time <- as.numeric(quantile(time_vec, probs = c(0.25, 0.5, 0.75), na.rm = TRUE))
  
  # Step 2. 构建生存公式
  fm <- as.formula(paste0("Surv(", time_col, ", ", status_col, ") ~ 1"))
  
  # Step 3. 计算 time-dependent Brier scores
  pe <- pec(
    object     = list(Cox = fit),
    formula    = fm,
    data       = data,
    times      = eval_time,
    cens.model = "cox",
    splitMethod = "none"
  )
  
  # Step 4. 提取结果
  # pec 的 AppErr 是 matrix: 行=时间点, 列=模型
  appErr <- as.data.frame(pe$AppErr)
  time_points <- as.numeric(rownames(appErr))
  model_col <- colnames(appErr)[1]
  df_brier <- data.frame(time = time_points, brier = appErr[[model_col]])
  
  # Step 5. 计算 IBS（积分）
  ibs_val <- pec::ibs(pe)
  trapz_ibs <- with(df_brier, sum(diff(time) * (head(brier, -1) + tail(brier, -1)) / 2) / (max(time) - min(time)))
  
  # Step 6. 绘图
  plot(df_brier$time, df_brier$brier, type = "b", pch = 19, col = "steelblue",
       xlab = "Time", ylab = "Brier Score",
       main = sprintf("Integrated Brier Score (IBS) = %.4f", ibs_val))
  grid()
  
  # Step 7. 输出结果
  cat("Evaluation times (25%, 50%, 75%):", paste(round(eval_time, 3), collapse = ", "), "\n")
  cat("Brier Scores:", paste(round(df_brier$brier, 4), collapse = ", "), "\n")
  cat("IBS (pec::ibs):", round(ibs_val, 4), "\n")
  cat("IBS (trapz approx):", round(trapz_ibs, 4), "\n")
  
  invisible(list(times = eval_time, brier_table = df_brier, IBS = ibs_val, IBS_trapz = trapz_ibs))
}

result <- evaluate_IBS(fit, data_I, time_col = "Y", status_col = "Delta")

```















  